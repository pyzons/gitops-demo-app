---
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-service-config
  namespace: ecommerce-backend
data:
  MONGODB_URI: "mongodb://admin:password123@mongodb-service.ecommerce-database.svc.cluster.local:27017/ecommerce?authSource=admin"
  PORT: "3003"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  namespace: ecommerce-backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
    spec:
      containers:
      - name: order-service
        image: node:16-alpine
        command: ["/bin/sh"]
        args: ["-c", "cp /code/* /app/ && cd /app && npm init -y && npm install express mongoose && node server.js"]
        ports:
        - containerPort: 3003
        envFrom:
        - configMapRef:
            name: order-service-config
        volumeMounts:
        - name: app-code
          mountPath: /code
        - name: app-workspace
          mountPath: /app
        workingDir: /app
      volumes:
      - name: app-code
        configMap:
          name: order-service-code
      - name: app-workspace
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
  namespace: ecommerce-backend
spec:
  selector:
    app: order-service
  ports:
  - port: 3003
    targetPort: 3003
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-service-code
  namespace: ecommerce-backend
data:
  server.js: |
    const express = require('express');
    const mongoose = require('mongoose');
    
    const app = express();
    app.use(express.json());
    
    mongoose.connect(process.env.MONGODB_URI);
    
    const orderSchema = new mongoose.Schema({
      userId: { type: String, required: true },
      items: [{
        productId: String,
        name: String,
        price: Number,
        quantity: Number
      }],
      total: { type: Number, required: true },
      status: { type: String, default: 'pending' },
      createdAt: { type: Date, default: Date.now }
    });
    
    const cartSchema = new mongoose.Schema({
      userId: { type: String, required: true, unique: true },
      items: [{
        productId: String,
        name: String,
        price: Number,
        quantity: Number
      }]
    });
    
    const Order = mongoose.model('Order', orderSchema);
    const Cart = mongoose.model('Cart', cartSchema);
    
    // Cart endpoints
    app.get('/cart/:userId', async (req, res) => {
      try {
        const cart = await Cart.findOne({ userId: req.params.userId });
        res.json(cart || { items: [] });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    
    app.post('/cart/:userId/add', async (req, res) => {
      try {
        const { productId, name, price, quantity } = req.body;
        let cart = await Cart.findOne({ userId: req.params.userId });
        
        if (!cart) {
          cart = new Cart({ userId: req.params.userId, items: [] });
        }
        
        const existingItem = cart.items.find(item => item.productId === productId);
        if (existingItem) {
          existingItem.quantity += quantity;
        } else {
          cart.items.push({ productId, name, price, quantity });
        }
        
        await cart.save();
        res.json(cart);
      } catch (error) {
        res.status(400).json({ error: error.message });
      }
    });
    
    app.delete('/cart/:userId/remove/:productId', async (req, res) => {
      try {
        const cart = await Cart.findOne({ userId: req.params.userId });
        if (cart) {
          cart.items = cart.items.filter(item => item.productId !== req.params.productId);
          await cart.save();
        }
        res.json(cart);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    
    // Order endpoints
    app.post('/orders', async (req, res) => {
      try {
        const { userId, items, total } = req.body;
        const order = new Order({ userId, items, total });
        await order.save();
        
        // Clear cart after order
        await Cart.findOneAndUpdate({ userId }, { items: [] });
        
        res.status(201).json(order);
      } catch (error) {
        res.status(400).json({ error: error.message });
      }
    });
    
    app.get('/orders/:userId', async (req, res) => {
      try {
        const orders = await Order.find({ userId: req.params.userId }).sort({ createdAt: -1 });
        res.json(orders);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    
    app.listen(process.env.PORT, () => {
      console.log(`Order service running on port ${process.env.PORT}`);
    });